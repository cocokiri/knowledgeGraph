<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<div id="container">
</div>

<body>
<style>
    .textBox {
        background: cornflowerblue;
        color: black;
    }
</style>
<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/14082/FileSaver.js'></script>
<script src="./svg.js"></script>
<script src="./svg.pathmorphing.js"></script>
<script src="text.js"></script>
<script>

    const draw = new SVG('container').size(window.innerWidth, window.innerHeight);
    // const drawText = new SVG('textSVG').size(window.innerWidth, window.innerHeight);
    // const drawCircle = new SVG('circleSVG').size(window.innerWidth, window.innerHeight);

    let data;
    let dat;
    function getData(path) {
        return new Promise(function (resolve, reject) {
            fetch(path)
                .then(
                    function (response) {
                        if (response.status !== 200) {
                            console.log('Looks like there was a problem. Status Code: ' +
                                response.status);
                            return;
                        }
                        // Examine the text in the response
                        response.json().then(function (data) {
                            console.log(data, "data");
                            resolve(data)
                        });
                    }
                )
                .catch(function (err) {
                    reject();
                    console.log('Fetch Error :-S', err);
                });
        })
    }

    let objs;
    let circles;
    let textViews;

    //TODO: drop shadows
    //      history timelines
    //      venn diagramming / only show tag overlaps

    getData('./data.json').then(rawData => {
        data = JSON.parse(JSON.stringify(rawData.slice(0, 200)))

        function cleanData(data) {
            dat = JSON.parse(JSON.stringify(data)) //don't do this if data is more than 2 layers deep!
            dat.map(d => d.vector = d.vector.split(' '));
            dat.map(d => {
                d.vector[0] = d.vector[0].slice(1);
                d.vector[d.vector.length - 1] = d.vector[d.vector.length - 1].slice(0, -1)
            })
            //data ==> entry.vector ==> entry
            dat.map(d => d.vector = d.vector.filter(s => s !== ""))
            dat.map(d => d.vector = d.vector.map((parseFloat)))
            return dat;
        }

        data = cleanData(data);

        next();

        //clean data
        function updateData(focus, data){
            setRelativeCenter(focus)(data)
                .map(d=>spaceOut(d));

            data.map((d, i, arr) => d.unitPos = percToUnitCirlce(i / arr.length - 1));
        }
        function next() {
            data = data.slice(0, 20)
            let focus = data[5];
            const centerPos = [window.innerWidth / 2, window.innerHeight / 2];

            updateData(focus, data);



            function updateGraph() {
                textViews.map(t => t.hide());
                circles.map(c => {
                    c.animate(1300).move(centerPos[0] - 15, centerPos[1] - 15)
                    updateData(focus, data);
                    circles.map((c, i) => c.data = data[i]);
                    textViews.map((t, i) => t.data = data[i]);
                })
                window.setTimeout(function () {
                    expandNodes();

                }, 1500)
            }




            circles = data.map((d) => draw.circle(30).attr(posForCircle(centerPos, d.distance, d.unitPos)));
            textViews = data.map((d) => draw.text(d.word).attr(posForText(centerPos, d.distance, d.unitPos)));

            circles.map((e, i) => e.data = data[i]);

            circles.map(c => c.click(function () {
                focus = c.data;
                focus.distance = 0;
                updateGraph()
            }))

            circles.map(c => c.add)
            draw.circle(60).attr(posForCircle(centerPos)).attr({fill: "#f03"})

        }

    })


    function backToCenter(circles, center) {
        circles.map(c => c.animate().move({cx: 400, cy: 400}))
    }
    //UTILS
    function vecDiff(v1, v2) {
        return Math.sqrt(
            vectorSubtract(v1, v2)
                .map(e => Math.pow(e, 2))
                .reduce((acc, val) => acc + val, 0)
        )
    }

    function randomOnUnitCirlce() {
        let rad = Math.random() * Math.PI * 2;
        let x = Math.cos(rad); //x of einheitskreis
        let y = Math.sin(rad); //y of einheitsKreis
        return [x, y]
    }

    function setRelativeCenter(focusEntry) {
        //mutates input
        return function (allEntries) {
            allEntries.map(e => {
                e.distance = vecDiff(e.vector, focusEntry.vector)
            });
            return allEntries;
        }
    }

    function percToUnitCirlce(percentage) {
        let rad = Math.PI * 2 * percentage
        let x = Math.cos(rad); //x of einheitskreis
        let y = Math.sin(rad); //y of einheitsKreis
        return [x, y]
    }

    function spaceOut(d){
        if (d.distance !== 0) {
            d.distance *=70;
            d.distance += 60
        }
    }

    function expandNodes() {
        circles.map(function (c) {
            c.animate(500).attr(posForCircle(centerPos, c.data.distance, c.data.unitPos))
                .afterAll(function () {
                    textViews.map(t => t.attr(posForText(centerPos, t.data.distance, t.data.unitPos)))
                    textViews.map(t => t.show());
                })
        })
    }

    function posForText(center, distance, rnd) {

        return {
            x: center[0] + rnd[0] * distance - 35,
            y: center[1] + rnd[1] * distance - 40
        }
    }

    function posForCircle(center, distance = 0, rnd) {
        if (distance == 0) {
            rnd = [0, 0]
        }
        return {
            cx: center[0] + rnd[0] * distance,
            cy: center[1] + rnd[1] * distance
        }
    }

    //make into multi-use Applicatives!!!
    function vectorSubtract(V1, V2) {
        return V1.map((e, i) => e - V2[i]);
    }



</script>
</body>
</html>

