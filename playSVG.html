<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<div id="container">
</div>

<body>
<style>
    .textBox {
        background: cornflowerblue;
        color: black;
    }
</style>
<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/14082/FileSaver.js'></script>
<script src="./svg.js"></script>
<script src="./svg.pathmorphing.js"></script>
<script src="text.js"></script>
<script>

    const draw = new SVG('container').size(window.innerWidth, window.innerHeight);
    const COLORS = {red: "red"};

    let data;
    let dat;
    let raw


    let circles;
    let textViews;
    let textBackgrounds;

    function spaceOut(d){
        if (d.distance !== 0) {
            d.distance *=3000;
            d.distance += 60
        }
    }

    //TODO: drop shadows
    //      history timelines
    //      venn diagramming / only show tag overlaps

    getData('./data.json').then(rawData => {
        raw = JSON.parse(JSON.stringify(rawData.slice(0, 1000)))
        raw = cleanData(raw);

        raw = raw.slice(0, 1000);
         //100 = vector lengthÃŸ
        let focus = raw[5];
        const centerPos = [window.innerWidth / 2, window.innerHeight / 2];

        updatePositionData(focus, raw);

        data = raw.sort((a,b) => a.distance - b.distance)
            .slice(0, 30)
        //a.distance > b.distance didn't work

        circles = data.map((d) => draw.circle(30).attr(posForCircle(centerPos, d.distance, d.unitPos)));
        textViews = data.map((d) => draw.text(d.word).attr(posForText(centerPos, d.distance, d.unitPos)));
        textViews.map(e=> e.attr({fill: "red"}))
        textBackgrounds = data.map((d) => draw.rect(d.word.length * 5, 10).attr({fill: "blue"}).attr(posForText(centerPos, d.distance, d.unitPos)));

        circles.map((e, i) => e.data = data[i]);
        textViews.map((t, i) => t.data = data[i]);


        //events
        circles.map(c => c.click(function () {
            focus = c.data;
            focus.distance = 0;
            updateAll(focus, data)
        }))


        //center Circle / Concept
        draw.circle(60).attr(posForCircle(centerPos)).attr({fill: "#f03"})


        function updatePositionData(focus, data){
            setRelativeCenter(focus)(data)
                .map(d=>spaceOut(d));

            data.map((d, i, arr) => d.unitPos = percToUnitCirlce(i / arr.length - 1));
        }

        function updateAll(focus, dat) {
            updatePositionData(focus, dat);
            updateNodeData();
            wait(collapseNodes, 700)
                .then(d => wait(expandNodes, 500))
        }

        function collapseNodes(duration) {
            textViews.map(t => t.hide());
            circles.map(c => c.animate(duration).move(centerPos[0] - 15, centerPos[1] - 15))
        }
        function expandNodes(duration) {
            circles.map(function (c) {
                c.animate(duration).attr(posForCircle(centerPos, c.data.distance, c.data.unitPos))
                    .afterAll(function () {
                        textViews.map(t => t.attr(posForText(centerPos, t.data.distance, t.data.unitPos)))
                        textViews.map(t => t.show());
                    })
            })
        }
    })





    function updateNodeData() {
        circles.map((c, i) => c.data = data[i]);
        textViews.map((t, i) => t.data = data[i]);
    }
    function wait(fn, timeout = 1500) {
        return new Promise(function(resolve, reject){
            try {
                fn(timeout);
                window.setTimeout(function () {
                    resolve()
                }, timeout + 100)
            }
            catch(error){
                console.error("Set timeout didn't work, error ==>", error)
                reject();
            }

        })
    }

    function backToCenter(circles, center) {
        circles.map(c => c.animate().move({cx: 400, cy: 400}))
    }
    //UTILS
    function vecDiff(v1, v2) {
        return Math.sqrt(
            vectorSubtract(v1, v2)
                .map(e => Math.pow(e, 2))
                .reduce((acc, val) => acc + val, 0)
        )
    }

    function randomOnUnitCirlce() {
        let rad = Math.random() * Math.PI * 2;
        let x = Math.cos(rad); //x of einheitskreis
        let y = Math.sin(rad); //y of einheitsKreis
        return [x, y]
    }

    function setRelativeCenter(focusEntry) {
        //mutates input
        return function (allEntries) {
            allEntries.map(e => {
                e.distance = vecDiff(e.vector, focusEntry.vector)
            });
            return allEntries;
        }
    }

    function cleanData(data) {
        dat = JSON.parse(JSON.stringify(data)) //don't do this if data is more than 2 layers deep!
        dat.map(d => d.vector = d.vector.split(' '));
        dat.map(d => {
            d.vector[0] = d.vector[0].slice(1);
            d.vector[d.vector.length - 1] = d.vector[d.vector.length - 1].slice(0, -1)
        })
        //data ==> entry.vector ==> entry
        dat.map(d => d.vector = d.vector.filter(s => s !== ""))
        dat.map(d => d.vector = d.vector.map((parseFloat)))
        return dat;
    }

    function percToUnitCirlce(percentage) {
        let rad = Math.PI * 2 * percentage
        let x = Math.cos(rad); //x of einheitskreis
        let y = Math.sin(rad); //y of einheitsKreis
        return [x, y]
    }





    function posForText(center, distance, rnd) {
        return {
            x: center[0] + rnd[0] * distance - 35,
            y: center[1] + rnd[1] * distance - 40
        }
    }

    function posForCircle(center, distance = 0, rnd) {
        if (distance == 0) {
            rnd = [0, 0]
        }
        return {
            cx: center[0] + rnd[0] * distance,
            cy: center[1] + rnd[1] * distance
        }
    }

    //make into multi-use Applicatives!!!
    function vectorSubtract(V1, V2) {
        return V1.map((e, i) => e - V2[i]);
    }

    function getData(path) {
        return new Promise(function (resolve, reject) {
            fetch(path)
                .then(
                    function (response) {
                        if (response.status !== 200) {
                            console.log('Looks like there was a problem. Status Code: ' +
                                response.status);
                            return;
                        }
                        // Examine the text in the response
                        response.json().then(function (data) {
                            console.log(data, "data");
                            resolve(data)
                        });
                    }
                )
                .catch(function (err) {
                    reject();
                    console.log('Fetch Error :-S', err);
                });
        })
    }



</script>
</body>
</html>

